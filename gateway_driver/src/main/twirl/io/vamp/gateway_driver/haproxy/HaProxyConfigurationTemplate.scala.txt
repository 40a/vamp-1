@import io.vamp.gateway_driver.haproxy.HaProxy
@import io.vamp.gateway_driver.haproxy.Mode
@(haproxy: HaProxy)
# HAProxy 1.6
global
  pidfile /opt/vamp/haproxy.pid
  server-state-file /opt/vamp/haproxy_server_state

  daemon
  maxconn 4096
  log /opt/vamp/haproxy.log.sock local0

  defaults
    log global
    mode http
    option dontlognull
    option redispatch
    option clitcpka
    option srvtcpka
    option http-keep-alive
    retries 3
    maxconn 500000

    # slowloris protection: clients should send their full http request in the configured time
    timeout http-request 5s
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

  listen stats
    bind :1988
    mode http
    stats enable
    stats uri /
    stats refresh 2s
    stats realm Haproxy\ Stats
    stats auth haproxy:haproxy

@for(frontend <- haproxy.frontends) {
# frontend: @frontend.name
frontend @frontend.lookup
  @if(frontend.bindIp.isDefined && frontend.bindPort.isDefined)       {bind @frontend.bindIp.get:@frontend.bindPort.get             }
  @if(frontend.mode == Mode.http) {
  option httplog
  log-format @haproxy.httpLogFormat
  }
  @if(frontend.mode == Mode.tcp) {
  option tcplog
  log-format @haproxy.tcpLogFormat
  }

  @if(frontend.options.httpClose)                                     {option http-server-close                                     }
  @if(frontend.unixSock.isDefined && frontend.sockProtocol.isDefined) {bind unix@@@frontend.unixSock.get @frontend.sockProtocol.get }

  mode @frontend.mode

  @* httpQuota and tcpQuota not supported yet.
  ###
  #
  # Spike/Rate Limiting & Quota Management
  #
  # We use a stick table to keep track of TCP connections rates and bytes send out.
  # On these metrics we set rules to designate upper limits. When limits are hit
  # we reroute the traffic to a specific abusers backend.
  #
  ###
  @if(frontend.httpQuota.isDefined) {
  # Start HTTP spike limit generation
  stick-table type ip size 200k expire @frontend.httpQuota.get.expiryTime store http_req_rate(@frontend.httpQuota.get.sampleWindow)
  # Values below are specific to the backend.
  # Track the request and set ACL's.
  tcp-request content track-sc1 src
  acl marked_as_abuser sc1_http_req_rate gt @frontend.httpQuota.get.rate
  use_backend abusers if marked_as_abuser
  # End HTTP spike limit generation.
  }
  @if(frontend.tcpQuota.isDefined) {
  # Start TCP spike limit generation
  stick-table type ip size 200k expire @frontend.tcpQuota.get.expiryTime store conn_rate(@frontend.tcpQuota.get.sampleWindow)
  # Values below are specific to the backend.
  # Track the request and set ACL's.
  tcp-request content track-sc2 src
  acl marked_as_abuser sc2_conn_rate gt @frontend.tcpQuota.get.rate
  use_backend abusers if marked_as_abuser
  # End TCP spike limit generation.
  }
  *@

  @for(filter <- frontend.filters) {
  # destination: @filter.destination.name
  @for(condition <- filter.conditions) {acl @condition.name @condition.definition
  }use_backend @filter.destination.lookup if @for(condition <- filter.conditions) {@if(condition.negate) {!}@condition.name }
  }

  # backend: @frontend.defaultBackend.name
  default_backend @frontend.defaultBackend.lookup
}

@for(backend <- haproxy.backends) {
# backend: @backend.name
backend @backend.lookup
  mode @backend.mode
  @if(backend.mode == Mode.http)        {balance roundrobin       }
  @if(backend.mode == Mode.tcp)         {balance leastconn        }
  @if(backend.sticky) {
  cookie @backend.lookup insert indirect nocache
  }

  @for(server <- backend.proxyServers) {
  # server: @server.name
  server @server.lookup unix@@@server.unixSock send-proxy weight @server.weight @if(backend.sticky) {check cookie @server.lookup}
  }
  @if(backend.servers.nonEmpty) {

  option forwardfor
  @for(server <- backend.servers) {
  # server: @server.name
  server @server.lookup @server.host:@server.port @if(backend.mode == Mode.http) {cookie @server.lookup} weight @server.weight maxconn @server.maxConn @if(server.checkInterval.isDefined) {check inter @server.checkInterval.get} @if(backend.sticky) {check cookie @server.lookup}
  }

  @if(backend.options.abortOnClose)     {option abortonclose      }
  @if(backend.options.allBackups)       {option allbackups        }
  @if(backend.options.checkCache)       {option checkcache        }
  @if(backend.options.forwardFor)       {option forwardfor        }
  @if(backend.options.httpClose)        {option http-server-close }
  @if(backend.options.httpCheck)        {option httpchk           }
  @if(backend.options.sslHelloCheck)    {option ssl-hello-chk     }
  @if(backend.options.tcpKeepAlive)     {option tcpka             }
  @if(backend.options.tcpSmartAccept)   {option tcp-smart-accept  }
  @if(backend.options.tcpSmartConnect)  {option tcp-smart-connect }
  @if(backend.options.tcpLog)           {option tcplog            }
  }
}
@*
backend abusers
  mode http
  errorfile 409 /opt/docker/configuration/error_pages/500rate.http
*@